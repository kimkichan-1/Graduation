# Unity 2D 액션 RPG 게임 졸업 프로젝트 보고서

---

## 1. 작품 개요

### 1.1 작품 개요

#### 게임 장르 및 컨셉
본 프로젝트는 Unity 6 엔진을 사용하여 개발한 2D 횡스크롤 액션 RPG 게임입니다. 플레이어는 다양한 무기를 선택하여 적들과 전투하고, 보스를 물리치며 성장하는 여정을 경험합니다.

**주요 특징:**
- 3가지 무기 시스템 (검, 창, 메이스)
- 레벨업 및 스탯 강화 시스템
- 카드 기반 주사위 전투 시스템 (보스전)
- 다양한 스테이지와 미니게임
- 세이브/로드 시스템 (3개 슬롯)

#### 게임 스토리 및 세계관
플레이어는 고대의 유적을 탐험하는 모험가가 되어, 각 스테이지를 클리어하고 강력한 보스들을 물리치며 세계를 구원하는 여정을 떠납니다. 여정 중에는 대장간에서 무기를 강화하고, 상점에서 아이템을 구매하며, 수중 던전에서는 산소를 관리하며 진행해야 합니다.

#### 핵심 게임플레이 메커니즘
- **탐험 모드**: 횡스크롤 플랫포머 방식의 스테이지 탐험
- **전투 시스템**: 실시간 액션 전투 (일반 적) + 턴 기반 카드 전투 (보스)
- **성장 시스템**: 경험치, 레벨업, 스탯 업그레이드, 장비 강화
- **미니게임**: 대장간 불꽃 수집 게임, 라이프맵 미니게임

---

### 1.2 작품 선정 배경

#### 개발 동기
2D 액션 RPG는 게임 개발의 핵심 요소들을 모두 포함하고 있어 졸업 프로젝트로 적합하다고 판단했습니다:
- 플레이어 컨트롤 및 물리 시스템
- AI 및 전투 시스템
- UI/UX 디자인
- 데이터 관리 및 저장 시스템
- 씬 관리 및 게임 상태 관리

#### 2D 액션 RPG 장르 선택 이유
1. **학습 목적**: Unity의 다양한 시스템을 깊이 있게 학습 가능
2. **구현 범위**: 3D보다 상대적으로 리소스 제작이 용이하여 시스템 구현에 집중 가능
3. **완성도**: 제한된 시간 내에 완성도 있는 게임 제작 가능
4. **확장성**: 기본 시스템 구축 후 다양한 기능 추가 가능

#### 프로젝트 목적 및 의의
- Unity 게임 엔진에 대한 깊이 있는 이해
- 게임 디자인 패턴 및 아키텍처 학습
- 프로젝트 관리 및 버전 관리 경험
- 완성도 있는 포트폴리오 작품 제작

---

### 1.3 유사 게임 분석

#### 벤치마크 게임 분석

**1. Hollow Knight**
- **참고한 요소**: 벽 슬라이드, 대시 메커니즘, 체력 시스템
- **학습 포인트**: 정교한 플레이어 컨트롤과 반응성

**2. Dead Cells**
- **참고한 요소**: 무기 시스템, 적 AI 패턴, 레벨 디자인
- **학습 포인트**: 빠른 전투 템포와 피드백

**3. Blasphemous**
- **참고한 요소**: 보스전 패턴, 체력 회복 시스템
- **학습 포인트**: 도전적인 난이도 설계

**4. Library of Ruina**
- **참고한 요소**: 주사위 기반 카드 전투 시스템
- **학습 포인트**: 전략적 전투 메커니즘

#### 참고한 게임 메커니즘
- 플레이어 이동: 점프, 대시, 벽 슬라이드
- 전투: 콤보 시스템, 무기별 차별화된 공격
- 보스전: 카드 선택 → 주사위 롤 → 클래시 해결
- 성장: 레벨업, 스탯 강화, 장비 업그레이드

#### 차별화 포인트
1. **하이브리드 전투 시스템**: 일반 전투는 실시간 액션, 보스전은 턴 기반 카드 게임
2. **다양한 무기 시스템**: 검(균형), 창(리치), 메이스(파워) 각각 다른 플레이 스타일
3. **통합된 미니게임**: 대장간, 라이프맵 등 메인 게임과 연결된 미니게임
4. **수중 스테이지**: 산소 관리가 필요한 독특한 스테이지

---

### 1.4 구현 범위 및 목표

#### 주요 구현 기능

**1. 플레이어 시스템**
- 이동, 점프, 대시, 벽 슬라이드
- 3종 무기 (검, 창, 메이스) 및 공격 시스템
- 체력, 공격력, 방어력, 이동속도 스탯 관리
- 레벨업 및 경험치 시스템

**2. 전투 시스템**
- 일반 적 AI: 순찰, 감지, 추적, 공격
- 중간보스 AI: 특수 패턴 (마법, 텔레포트)
- 보스 전투: 주사위 기반 카드 전투 시스템
- 무기별 데미지 계산 및 피격 시스템

**3. 세이브/로드 시스템**
- 3개 슬롯 지원
- JSON 기반 데이터 저장
- 자동 저장 (씬 전환 시)
- 플레이어 위치, 스탯, 인벤토리 저장

**4. 인벤토리 및 상점 시스템**
- 아이템 획득 및 관리
- 포션 사용 (체력 회복)
- 상점: 랜덤 아이템 판매, 새로고침 기능
- 스탯 업그레이드 아이템

**5. 미니게임**
- 대장간: 불꽃 수집 게임 (보상: 골드, XP, 공격력 증가)
- 라이프맵: 특수 미니게임

**6. UI/UX**
- 메인 메뉴, 무기 선택, 세이브 슬롯 선택
- HUD: 체력, 스탯 표시
- 레벨업 UI: 스탯 선택 시스템
- 일시정지 메뉴
- 대미지 텍스트 (floating text)

**7. 씬 관리**
- 포털 시스템 (확인 UI 포함)
- 플레이어 스폰 위치 관리
- 미니게임 복귀 시스템
- DontDestroyOnLoad 싱글톤 관리

**8. 스테이지별 특수 시스템**
- Stage3: 수영 메커니즘, 산소 게이지, 산소 회복 구역

#### 개발 목표 및 완성도 기준
- ✅ 모든 핵심 시스템 구현 완료
- ✅ 메인 메뉴부터 게임 종료까지 전체 플로우 완성
- ✅ 3개 이상의 스테이지 및 보스전 구현
- ✅ 세이브/로드 시스템 안정성 확보
- ✅ 버그 없는 플레이 경험 제공

---

### 1.5 개발 환경

#### 소프트웨어 환경
- **게임 엔진**: Unity 6000.0.41f1 (Unity 6)
- **개발 언어**: C# (.NET Framework)
- **IDE**: Visual Studio 2022
- **버전 관리**: Git, GitHub
- **타겟 플랫폼**: Windows (PC)

#### 하드웨어 환경
- **운영체제**: Windows 11
- **개발 환경**: Windows PC

#### 주요 사용 Unity 패키지
- Unity 2D Pixel Perfect
- Unity Timeline
- Unity Input System (기본 입력 사용)
- TextMeshPro

#### 개발 도구
- **그래픽**: Unity Sprite Editor, 외부 에셋
- **사운드**: Unity Audio Source, AudioClip
- **애니메이션**: Unity Animator, Animation Controller

---

## 2. 관련 기술

### 2.1 Unity 2D 게임 개발

#### Unity 2D 엔진 개요
Unity는 크로스 플랫폼 게임 엔진으로, 2D 게임 개발을 위한 다양한 도구를 제공합니다. 본 프로젝트에서는 Unity 6 (6000.0.41f1)을 사용했습니다.

**Unity 2D의 주요 특징:**
- 2D Renderer 및 Sprite 시스템
- 2D Physics (Rigidbody2D, Collider2D)
- Tilemap 시스템 (레벨 디자인)
- 2D 애니메이션 시스템
- Sorting Layer 및 Order in Layer (렌더링 순서 관리)

#### Rigidbody2D 물리 시스템
본 프로젝트에서는 Unity 6의 새로운 물리 API를 사용합니다.

**주요 변경사항:**
```csharp
// 구 버전 (Unity 2D Physics)
rigidbody2D.velocity = new Vector2(x, y);

// Unity 6 (새 버전)
rigidbody2D.linearVelocity = new Vector2(x, y);
```

**물리 시스템 활용:**
- **이동**: `linearVelocity.x` 조정
- **점프**: `linearVelocity.y`에 점프력 적용
- **대시**: 순간적인 velocity 변경
- **중력**: Gravity Scale 조정
- **충돌 감지**: OnCollisionEnter2D, OnTriggerEnter2D

**Rigidbody2D 설정:**
- Body Type: Dynamic (플레이어, 적), Kinematic (이동 플랫폼)
- Constraints: Freeze Rotation Z (2D에서 회전 방지)
- Collision Detection: Continuous (빠른 움직임 감지)

#### 2D 애니메이션 시스템
Unity의 Animator Controller를 사용하여 상태 기반 애니메이션을 구현했습니다.

**애니메이션 파라미터:**
- **Float**: Speed (이동 속도)
- **Bool**: Grounded, HasSword, Dash, Wall
- **Trigger**: isHurt, isDead, isKnockedBack

**애니메이션 이벤트:**
```csharp
// Animation Event 예시
public void EnableAttackHitbox()  // 공격 활성화
public void DisableAttackHitbox() // 공격 비활성화
public void PlayAttackSound()     // 사운드 재생
```

**애니메이션 전환:**
- Has Exit Time: false (즉시 전환)
- Transition Duration: 0.1s (부드러운 전환)
- Interruption Source: Current State (현재 상태에서 중단 가능)

#### Tilemap 및 레벨 디자인
Tilemap을 사용하여 스테이지 레벨을 디자인했습니다.

**Tilemap 구조:**
- Ground Layer: 바닥, 벽
- Decoration Layer: 배경 장식
- Platform Layer: 플랫폼 (통과 가능)

**Tilemap Collider 2D:**
- Composite Collider 2D 사용 (최적화)
- Used by Composite 체크 (여러 타일을 하나의 콜라이더로 병합)

---

### 2.2 게임 디자인 패턴

#### 싱글톤 패턴 (Singleton Pattern)
게임 전역에서 하나의 인스턴스만 존재해야 하는 매니저 클래스에 적용했습니다.

**구현 예시:**
```csharp
public class PlayerController : MonoBehaviour
{
    public static PlayerController Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

**적용된 클래스:**
- `PlayerController.Instance` - 플레이어 제어
- `GameManager.Instance` - 게임 상태 및 세이브/로드
- `SaveManager.Instance` - 파일 I/O
- `Inventory.instance` - 인벤토리 관리
- `ShopManager.Instance` - 상점 시스템
- `BossGameManager.Instance` - 보스 전투 상태 관리

**주의사항:**
- DontDestroyOnLoad로 씬 전환 시에도 유지
- 메인 메뉴 복귀 시 수동으로 정리 필요 (메모리 누수 방지)

#### 옵저버 패턴 (Observer Pattern)
이벤트 기반 시스템으로 UI 업데이트, 게임 상태 변경 등에 활용했습니다.

**구현 예시:**
```csharp
// Inventory.cs
public delegate void OnItemChanged();
public OnItemChanged onItemChangedCallback;

public void Add(PotionItemData item)
{
    items.Add(item);
    if (onItemChangedCallback != null)
        onItemChangedCallback.Invoke();
}

// InventoryUI.cs
void Start()
{
    inventory = Inventory.instance;
    inventory.onItemChangedCallback += UpdateUI;
}
```

**적용 사례:**
- 인벤토리 변경 → UI 업데이트
- 플레이어 스탯 변경 → HUD 업데이트
- 적 사망 → 아이템 드롭
- 대화 완료 → 미니게임 시작

#### 상태 머신 패턴 (State Machine Pattern)
적 AI와 보스 전투 시스템에 상태 머신을 적용했습니다.

**적 AI 상태:**
```csharp
private enum EnemyState
{
    Idle,      // 대기
    Patrol,    // 순찰
    Chase,     // 추적
    Attack,    // 공격
    Hurt,      // 피격
    Dead       // 사망
}
```

**상태 전환 로직:**
```csharp
void UpdateState()
{
    switch (currentState)
    {
        case EnemyState.Patrol:
            if (PlayerInRange())
                ChangeState(EnemyState.Chase);
            break;
        case EnemyState.Chase:
            if (PlayerInAttackRange())
                ChangeState(EnemyState.Attack);
            else if (!PlayerInRange())
                ChangeState(EnemyState.Patrol);
            break;
    }
}
```

**보스 전투 상태:**
```csharp
public enum GameState
{
    Exploration,  // 탐험 모드
    Battle        // 전투 모드
}
```

#### 오브젝트 풀링 (Object Pooling)
자주 생성/삭제되는 오브젝트(대미지 텍스트, 이펙트 등)의 성능 최적화를 위해 오브젝트 풀링을 적용했습니다.

**개념:**
- 오브젝트를 미리 생성해두고 재사용
- Instantiate/Destroy 호출 횟수 감소 → 성능 향상
- 메모리 단편화 방지

**적용 대상:**
- 대미지 텍스트 (DamageText)
- 공격 이펙트
- 발사체 (Spell, 화살 등)

---

### 2.3 데이터 지속성 기술

#### JSON 직렬화 (Unity JsonUtility)
플레이어 데이터를 JSON 형식으로 저장/로드합니다.

**SaveData 클래스:**
```csharp
[System.Serializable]
public class SaveData
{
    // 플레이어 스탯
    public int playerLevel;
    public int currentXP;
    public int maxHP;
    public int currentHP;
    public int attackPower;
    public int defensePower;
    public int currentMoney;

    // 무기
    public bool hasSword;
    public bool hasLance;
    public bool hasMace;

    // 인벤토리
    public List<PotionSaveData> potionItems;

    // 씬 정보
    public string currentScene;
    public Vector3 playerPosition;

    // 메타데이터
    public int slotNumber;
    public string saveTime;
    public float playTime;
    public bool isEmpty;
}
```

**직렬화/역직렬화:**
```csharp
// 저장
string json = JsonUtility.ToJson(saveData, true);
File.WriteAllText(path, json);

// 로드
string json = File.ReadAllText(path);
SaveData data = JsonUtility.FromJson<SaveData>(json);
```

**저장 위치:**
```csharp
string savePath = Application.persistentDataPath + "/Saves/";
// Windows: C:/Users/[Username]/AppData/LocalLow/[CompanyName]/[ProductName]/Saves/
```

#### ScriptableObject 기반 데이터 관리
재사용 가능한 게임 데이터를 ScriptableObject로 관리합니다.

**주요 ScriptableObject:**

1. **PotionItemData.cs**
```csharp
[CreateAssetMenu(fileName = "New Potion", menuName = "Inventory/Potion")]
public class PotionItemData : ScriptableObject
{
    public string itemName;
    public Sprite icon;
    public int healthRestoreAmount;
    public string description;
}
```

2. **ShopItemData.cs**
```csharp
[CreateAssetMenu(fileName = "New Shop Item", menuName = "Shop/Shop Item Data")]
public class ShopItemData : ScriptableObject
{
    public string itemName;
    public Sprite icon;
    public int price;
    public ItemType itemType;
    public int effectValue;
}
```

3. **CombatPage.cs** (보스 전투 카드)
```csharp
[CreateAssetMenu(fileName = "New Combat Page", menuName = "Combat Page")]
public class CombatPage : ScriptableObject
{
    public string pageName;
    public int lightCost;
    public int cooldownTurns;
    public CombatDice[] dices;
    public bool isSingleUse;
}
```

**장점:**
- Inspector에서 직접 편집 가능
- 여러 오브젝트에서 공유 가능
- 메모리 효율적 (인스턴스 생성 불필요)
- 빌드 시 에셋으로 포함

#### DontDestroyOnLoad 씬 간 데이터 유지
씬이 전환되어도 특정 오브젝트를 유지하는 기술입니다.

**구현:**
```csharp
void Awake()
{
    if (Instance == null)
    {
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    else
    {
        Destroy(gameObject);
    }
}
```

**적용 대상:**
- PlayerController
- GameManager
- SaveManager
- Inventory
- UI Canvas (선택적)

**주의사항:**
```csharp
// DontDestroyOnLoadManager.cs
// instanceId 기반 Dictionary로 중복 방지
private static Dictionary<string, GameObject> instances = new Dictionary<string, GameObject>();

void Awake()
{
    if (!isReturningToMainMenu)
    {
        if (instances.ContainsKey(instanceId))
        {
            Destroy(gameObject);
            return;
        }
        instances.Add(instanceId, gameObject);
        DontDestroyOnLoad(gameObject);
    }
}
```

#### 정적 클래스를 통한 크로스씬 데이터 공유
씬 간에 간단한 데이터를 전달할 때 정적 변수를 사용합니다.

**예시:**
```csharp
// GameData.cs
public static class GameData
{
    public static string SelectedWeapon;
}

// WeaponChoice.cs (무기 선택 씬)
public void SelectSword()
{
    GameData.SelectedWeapon = "Sword";
    SceneManager.LoadScene("LoadGame");
}

// GameManager.cs (게임 시작 시)
void Start()
{
    if (GameData.SelectedWeapon == "Sword")
    {
        player.hasSword = true;
    }
}
```

**정적 데이터 예시:**
- `GameData.SelectedWeapon` - 선택된 무기
- `PortalReturnData` - 포털 복귀 정보
- `PortalController.usedPortalIDs` - 사용된 포털 추적
- `MidBossController.completedEventIDs` - 완료된 이벤트
- `StatueInteraction.previousSceneName` - 이전 씬 이름
- `BlacksmithMinigameManager.isGamePausedByManager` - 시간 정지 플래그
- `DontDestroyOnLoadManager.isReturningToMainMenu` - 메인 메뉴 복귀 플래그

---

### 2.4 UI/UX 시스템

#### Unity UI (Canvas, UI 이벤트 시스템)
Unity의 Canvas 시스템을 사용하여 모든 UI를 구현했습니다.

**Canvas 설정:**
- **Render Mode**: Screen Space - Overlay (카메라 독립적)
- **Canvas Scaler**: Scale With Screen Size (해상도 대응)
  - Reference Resolution: 1920x1080
  - Match: 0.5 (Width/Height 균형)

**UI 계층 구조:**
```
Canvas (Main UI)
├── HUD Panel (체력, 스탯)
├── Inventory Panel
├── Level Up Panel
├── Pause Menu Panel
└── Damage Text Canvas (별도 Canvas)
```

**UI 이벤트 시스템:**
```csharp
// 버튼 클릭 이벤트
public void OnButtonClick()
{
    // 처리 로직
}

// 호버 이벤트
public class ButtonHoverEffect : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    public void OnPointerEnter(PointerEventData eventData)
    {
        // 마우스 오버 시 처리
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        // 마우스 아웃 시 처리
    }
}
```

#### 인벤토리 드래그 앤 드롭
인벤토리 아이템을 드래그하여 사용하는 시스템입니다.

**구현:**
```csharp
public class InventorySlot : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    public void OnBeginDrag(PointerEventData eventData)
    {
        // 드래그 시작
        canvasGroup.blocksRaycasts = false;
    }

    public void OnDrag(PointerEventData eventData)
    {
        // 드래그 중
        rectTransform.anchoredPosition += eventData.delta / canvas.scaleFactor;
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        // 드래그 종료
        canvasGroup.blocksRaycasts = true;

        // 플레이어에 드롭 시 아이템 사용
        if (IsOverPlayer(eventData.position))
        {
            UseItem();
        }
    }
}
```

#### 동적 UI 업데이트
플레이어 스탯 변경 시 UI를 실시간으로 업데이트합니다.

**옵저버 패턴 활용:**
```csharp
// PlayerStats.cs
public void AddXP(int amount)
{
    currentXP += amount;
    CheckLevelUp();
    UpdateStatsUI();
}

private void UpdateStatsUI()
{
    if (PlayerController.Instance != null)
    {
        PlayerController.Instance.UpdateAllStatsUI();
    }
}

// PlayerController.cs
public void UpdateAllStatsUI()
{
    if (statsUIManager != null)
    {
        statsUIManager.UpdateAllUI();
    }
}

// StatsUIManager.cs
public void UpdateAllUI()
{
    UpdateHealthUI();
    UpdateXPUI();
    UpdateStatsUI();
    UpdateCurrencyUI();
}
```

#### 레벨업 시스템 UI
레벨업 시 스탯을 선택할 수 있는 UI를 표시합니다.

**레벨업 UI 플로우:**
1. 경험치가 최대치 도달
2. 레벨업 발생
3. 시간 정지 (Time.timeScale = 0)
4. 레벨업 패널 표시
5. 플레이어가 스탯 선택 (공격력, 방어력, 체력, 이동속도)
6. 선택 적용 및 패널 닫기
7. 시간 재개 (Time.timeScale = 1)

**미니게임 중 레벨업 처리:**
```csharp
// PlayerStats.cs
private void CheckLevelUp()
{
    if (currentXP >= xpToNextLevel)
    {
        LevelUp();

        // 미니게임 중에는 레벨업 UI를 나중에 표시
        string currentScene = SceneManager.GetActiveScene().name;
        if (currentScene == "AncientBlacksmith" || currentScene == "LifeHeartMap")
        {
            isLevelUpPending = true;
        }
        else
        {
            ShowLevelUpPanel();
        }
    }
}

// 미니게임 종료 후
public void ShowPendingLevelUpPanel()
{
    if (isLevelUpPending)
    {
        ShowLevelUpPanel();
        isLevelUpPending = false;
    }
}
```

**Time.timeScale 관리:**
- `Time.timeScale = 0`: 게임 일시정지 (UI만 작동)
- `Time.timeScale = 1`: 게임 정상 속도
- `Time.unscaledDeltaTime`: timeScale 영향 받지 않는 시간 (UI 애니메이션용)

---

## 3. 구현 내용

### 3.1 게임 시스템 아키텍처

#### 3.1.1 전체 시스템 구조도

본 프로젝트는 11개의 주요 시스템으로 구성되어 있습니다:

```
┌─────────────────────────────────────────────────────────────┐
│                        Game Manager                          │
│  (Save/Load Orchestration, Game State Management)          │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
   ┌────▼────┐          ┌────▼────┐          ┌────▼────┐
   │ Player  │          │ Monster │          │  Scene  │
   │ System  │◄────────►│ System  │          │ Manager │
   └─────────┘          └─────────┘          └─────────┘
        │                     │                     │
        │                     │                     │
   ┌────▼────┐          ┌────▼────┐          ┌────▼────┐
   │  Stats  │          │ Item    │          │ Portal  │
   │ Manager │          │ Drop    │          │ System  │
   └─────────┘          └─────────┘          └─────────┘
        │
   ┌────▼────┐
   │   UI    │
   │ System  │
   └─────────┘
        │
   ┌────┴────┬─────────┬─────────┬─────────┐
   │         │         │         │         │
┌──▼──┐ ┌───▼──┐ ┌───▼──┐ ┌───▼──┐ ┌───▼──┐
│ HUD │ │Inven-│ │Level │ │ Shop │ │Pause │
│     │ │tory  │ │ Up   │ │      │ │ Menu │
└─────┘ └──────┘ └──────┘ └──────┘ └──────┘

Special Systems:
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│  Boss   │ │Minigame │ │ Stage3  │ │  Save   │
│ Battle  │ │ System  │ │Underwater│ │ System  │
└─────────┘ └─────────┘ └─────────┘ └─────────┘
```

**데이터 흐름도:**

```
Player Input
    │
    ▼
PlayerController ──────► Rigidbody2D (Physics)
    │                         │
    │                         ▼
    ├──────────────► Animator (Animation)
    │
    ├──────────────► PlayerStats ──────► LevelUpUIManager
    │                    │
    │                    ▼
    └──────────────► PlayerHealth ──────► HUD UI
                         │
                         ▼
                    DamageCalculation
                         │
                         ▼
                    MonsterHealth ──────► ItemDrop
                         │
                         ▼
                    Death Animation
                         │
                         ▼
                    XP Grant to Player
```

**씬 전환 구조:**

```
Main (메인 메뉴)
  │
  ├──► New Game Flow:
  │      │
  │      ├──► Weapon (무기 선택)
  │      │      │
  │      │      └──► LoadGame (슬롯 선택)
  │      │             │
  │      │             └──► Stage1 (게임 시작)
  │      │
  │      └──► Load Game Flow:
  │             │
  │             └──► LoadGame (슬롯 선택)
  │                    │
  │                    └──► [저장된 씬] (게임 재개)
  │
  └──► Stage Flow:
         │
         ├──► Stage1
         │      │
         │      ├──► Portal → Stage2
         │      ├──► Portal → Shop
         │      ├──► Portal → AncientBlacksmith (미니게임)
         │      └──► Boss Portal → Boss1
         │
         ├──► Stage2
         │      │
         │      ├──► Portal → Stage3
         │      └──► Boss Portal → Boss2
         │
         └──► Stage3 (Underwater)
                │
                └──► Portal → Stage1 (또는 다른 씬)
```

---

#### 3.1.2 핵심 클래스 다이어그램

**플레이어 시스템 클래스 구조:**

```
┌─────────────────────────────────────┐
│       PlayerController              │
│  (싱글톤, DontDestroyOnLoad)        │
├─────────────────────────────────────┤
│ + Instance : PlayerController       │
│ - rb : Rigidbody2D                  │
│ - animator : Animator               │
│ - hasSword : bool                   │
│ - hasLance : bool                   │
│ - hasMace : bool                    │
├─────────────────────────────────────┤
│ + Move()                            │
│ + Jump()                            │
│ + Dash()                            │
│ + Attack()                          │
│ + TakeDamage(int)                   │
│ + RecalculateStats()                │
│ + UpdateAllStatsUI()                │
└─────────────────────────────────────┘
              │
              │ RequireComponent
              │
      ┌───────┴───────┬────────────┐
      │               │            │
┌─────▼─────┐  ┌─────▼─────┐  ┌──▼──────┐
│PlayerStats│  │PlayerHealth│ │Character│
│           │  │            │  │Stats    │
├───────────┤  ├────────────┤  ├─────────┤
│+ level    │  │+ maxHP     │  │+ deck   │
│+ currentXP│  │+ currentHP │  │+ light  │
│+ money    │  │+ defense   │  │+ hp     │
│+ bonusAtk │  ├────────────┤  ├─────────┤
│+ bonusDef │  │+ TakeDamage│  │+ UsePage│
│+ bonusSpd │  │+ Heal()    │  │+ DrawCard│
├───────────┤  │+ Die()     │  └─────────┘
│+ AddXP()  │  └────────────┘
│+ LevelUp()│       │
│+ AddMoney│        │ 피격 시
└───────────┘       ▼
      │        Invincibility
      │        Frames
      ▼
  LevelUpUI
```

**적 AI 시스템 클래스 구조:**

```
┌──────────────────────────────────────┐
│        MonsterController              │
│    (일반 몬스터 AI 베이스)            │
├──────────────────────────────────────┤
│ - currentState : EnemyState          │
│ - target : Transform (Player)        │
│ - detectionRange : float             │
│ - attackRange : float                │
│ - moveSpeed : float                  │
├──────────────────────────────────────┤
│ + UpdateState()                      │
│ + Patrol()                           │
│ + Chase()                            │
│ + Attack()                           │
│ + CheckGround()                      │
│ + CheckWall()                        │
└──────────────────────────────────────┘
                 △
                 │ 상속
        ┌────────┴────────┐
        │                 │
┌───────▼────────┐  ┌────▼────────────┐
│Stage1MidBossAI │  │Stage2MidBossAI  │
├────────────────┤  ├─────────────────┤
│+ CastSpell()   │  │+ Teleport()     │
│+ SummonSpell() │  │+ TeleportTo()   │
└────────────────┘  └─────────────────┘
        │                 │
        │                 │
        └────────┬────────┘
                 │
        ┌────────▼────────┐
        │  MonsterHealth  │
        ├─────────────────┤
        │+ currentHP      │
        │+ maxHP          │
        │+ defense        │
        ├─────────────────┤
        │+ TakeDamage()   │
        │+ Die()          │
        │+ DieRoutine()   │
        └─────────────────┘
                 │
                 ▼
        ┌─────────────────┐
        │   ItemDrop      │
        ├─────────────────┤
        │+ dropItems[]    │
        │+ dropChance     │
        ├─────────────────┤
        │+ DropItems()    │
        └─────────────────┘
```

**매니저 클래스 관계도:**

```
┌─────────────────────────────────────────┐
│           GameManager                    │
│     (싱글톤, DontDestroyOnLoad)         │
├─────────────────────────────────────────┤
│ + Instance : GameManager                │
│ + currentSaveSlot : int                 │
│ + isNewGame : bool                      │
│ + selectedWeapon : string               │
├─────────────────────────────────────────┤
│ + SaveCurrentGame()                     │
│ + LoadGameFromSlot(int)                 │
│ + ApplySaveData(SaveData)               │
│ + PerformAutoSave()                     │
│ + PrepareNewGame()                      │
└─────────────────────────────────────────┘
                 │
                 │ 사용
                 ▼
┌─────────────────────────────────────────┐
│          SaveManager                     │
│     (싱글톤, DontDestroyOnLoad)         │
├─────────────────────────────────────────┤
│ + Instance : SaveManager                │
│ - savePath : string                     │
├─────────────────────────────────────────┤
│ + SaveGame(SaveData, int)               │
│ + LoadGame(int) : SaveData              │
│ + DeleteSave(int)                       │
│ + GetAllSaveSlots() : SaveData[]        │
└─────────────────────────────────────────┘
                 │
                 │ 직렬화
                 ▼
┌─────────────────────────────────────────┐
│            SaveData                      │
│         (Serializable)                   │
├─────────────────────────────────────────┤
│ + playerLevel : int                     │
│ + currentXP : int                       │
│ + maxHP : int                           │
│ + currentHP : int                       │
│ + attackPower : int                     │
│ + defensePower : int                    │
│ + currentMoney : int                    │
│ + hasSword : bool                       │
│ + hasLance : bool                       │
│ + hasMace : bool                        │
│ + potionItems : List<PotionSaveData>    │
│ + currentScene : string                 │
│ + playerPosition : Vector3              │
│ + saveTime : string                     │
│ + playTime : float                      │
│ + isEmpty : bool                        │
├─────────────────────────────────────────┤
│ + CreateEmptySlot(int) : SaveData       │
│ + GetSummary() : string                 │
│ + UpdateSaveTime()                      │
└─────────────────────────────────────────┘

Other Managers:
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  Inventory   │  │ ShopManager  │  │BossGameMgr   │
│  (싱글톤)    │  │  (싱글톤)    │  │  (싱글톤)    │
├──────────────┤  ├──────────────┤  ├──────────────┤
│+ items[]     │  │+ shopItems[] │  │+ currentState│
├──────────────┤  ├──────────────┤  ├──────────────┤
│+ Add()       │  │+ Purchase()  │  │+ SetState()  │
│+ Remove()    │  │+ Refresh()   │  └──────────────┘
│+ UsePotion() │  └──────────────┘
└──────────────┘
```

---

#### 3.1.3 데이터베이스 스키마 (저장 데이터 구조)

**SaveData 구조 (JSON):**

```json
{
  "slotNumber": 1,
  "isEmpty": false,
  "saveTime": "2025-11-03 14:30:25",
  "playTime": 1234.56,

  "playerLevel": 5,
  "currentXP": 150,
  "xpToNextLevel": 200,

  "maxHP": 120,
  "currentHP": 85,
  "attackPower": 25,
  "defensePower": 10,
  "moveSpeed": 5.5,
  "currentMoney": 350,

  "hasSword": true,
  "hasLance": false,
  "hasMace": true,

  "potionItems": [
    {
      "itemName": "Health Potion",
      "quantity": 3
    },
    {
      "itemName": "Mana Potion",
      "quantity": 1
    }
  ],

  "currentScene": "Stage2",
  "playerPosition": {
    "x": 12.5,
    "y": 2.0,
    "z": 0.0
  }
}
```

**PlayerStats 데이터 구조:**

```csharp
public class PlayerStats : MonoBehaviour
{
    // 레벨 시스템
    public int level = 1;
    public int currentXP = 0;
    public int xpToNextLevel = 100;

    // 보너스 스탯 (장비/업그레이드)
    public int bonusAttackPower = 0;
    public int bonusDefensePower = 0;
    public float bonusMoveSpeed = 0f;

    // 재화
    public int money = 0;

    // 레벨업 대기
    public bool isLevelUpPending = false;

    // 메서드
    public void AddXP(int amount)
    public void AddMoney(int amount)
    public bool SpendMoney(int amount)
    public void LevelUp()
}
```

**Inventory 데이터 구조:**

```csharp
public class Inventory : MonoBehaviour
{
    public static Inventory instance;

    // 인벤토리 아이템
    public List<PotionItemData> items = new List<PotionItemData>();
    public int inventorySize = 20;

    // 콜백
    public delegate void OnItemChanged();
    public OnItemChanged onItemChangedCallback;

    // 메서드
    public void Add(PotionItemData item)
    public void Remove(PotionItemData item)
    public bool IsFull()
    public int GetItemCount(PotionItemData item)
}
```

**PotionItemData (ScriptableObject):**

```csharp
[CreateAssetMenu(fileName = "New Potion", menuName = "Inventory/Potion")]
public class PotionItemData : ScriptableObject
{
    public string itemName;
    public Sprite icon;
    public int healthRestoreAmount;
    public string description;
}
```

**ShopItemData (ScriptableObject):**

```csharp
[CreateAssetMenu(fileName = "New Shop Item", menuName = "Shop/Shop Item Data")]
public class ShopItemData : ScriptableObject
{
    public enum ItemType
    {
        Potion,
        AttackUpgrade,
        DefenseUpgrade,
        HealthUpgrade,
        SpeedUpgrade
    }

    public string itemName;
    public Sprite icon;
    public int price;
    public ItemType itemType;
    public int effectValue;
    public float iconScale = 1f;
    public PotionItemData potionData;

    public void ApplyEffect()
    {
        switch (itemType)
        {
            case ItemType.Potion:
                Inventory.instance.Add(potionData);
                break;
            case ItemType.AttackUpgrade:
                PlayerStats.bonusAttackPower += effectValue;
                break;
            // ...
        }
    }
}
```

**CombatPage (ScriptableObject) - 보스 전투 카드:**

```csharp
[CreateAssetMenu(fileName = "New Combat Page", menuName = "Combat Page")]
public class CombatPage : ScriptableObject
{
    public string pageName;
    public Sprite cardArt;
    public int lightCost;
    public int cooldownTurns;
    public CombatDice[] dices;
    public bool isSingleUse;
}

[System.Serializable]
public class CombatDice
{
    public enum DiceType { Attack, Defense }

    public DiceType type;
    public int minValue;
    public int maxValue;

    public int Roll()
    {
        return Random.Range(minValue, maxValue + 1);
    }
}
```

**저장 파일 구조:**

```
Application.persistentDataPath/
└── Saves/
    ├── SaveSlot1.json
    ├── SaveSlot2.json
    └── SaveSlot3.json
```

**Auto-Save 트리거:**
- 씬 전환 시 (OnSceneLoaded 이벤트)
- 제외 씬: Main, LoadGame, Weapon, HowToPlay, Setting
- 0.5초 지연 후 자동 저장
- currentSaveSlot > 0일 때만 실행

---

### 3.2 주요 시스템 구현

#### 3.2.1 플레이어 시스템

**이동 및 점프 메커니즘**

플레이어의 기본 이동과 점프는 Rigidbody2D의 linearVelocity를 직접 제어하여 구현했습니다.

```csharp
// PlayerController.cs - Move()
void Move()
{
    float moveInput = Input.GetAxisRaw("Horizontal");

    // 이동 속도 계산 (기본 속도 + 보너스)
    float totalMoveSpeed = moveSpeed + playerStats.bonusMoveSpeed;

    // velocity 설정
    rb.linearVelocity = new Vector2(moveInput * totalMoveSpeed, rb.linearVelocity.y);

    // 애니메이터 업데이트
    animator.SetFloat("Speed", Mathf.Abs(moveInput));

    // 스프라이트 방향 전환
    if (moveInput > 0)
        transform.localScale = new Vector3(1, 1, 1);
    else if (moveInput < 0)
        transform.localScale = new Vector3(-1, 1, 1);
}
```

```csharp
// PlayerController.cs - Jump()
void Jump()
{
    if (Input.GetKeyDown(KeyCode.K) && isGrounded)
    {
        rb.linearVelocity = new Vector2(rb.linearVelocity.x, jumpForce);
        animator.SetTrigger("Jump");
    }
}

void CheckGround()
{
    // OverlapCircle로 땅 체크
    isGrounded = Physics2D.OverlapCircle(groundCheck.position, groundCheckRadius, groundLayer);
    animator.SetBool("Grounded", isGrounded);
}
```

**점프 파라미터:**
- `jumpForce = 12f` - 점프 힘
- `groundCheckRadius = 0.2f` - 땅 감지 반경
- `groundLayer` - Ground 레이어 마스크

**대시 및 벽 슬라이드**

대시는 코루틴을 사용하여 짧은 시간 동안 빠르게 이동합니다.

```csharp
// PlayerController.cs - Dash()
void Update()
{
    if (Input.GetKeyDown(KeyCode.L) && canDash)
    {
        StartCoroutine(Dash());
    }
}

IEnumerator Dash()
{
    canDash = false;
    isDashing = true;
    animator.SetBool("Dash", true);

    float originalGravity = rb.gravityScale;
    rb.gravityScale = 0f; // 중력 무시

    // 대시 방향
    float dashDirection = transform.localScale.x;
    rb.linearVelocity = new Vector2(dashDirection * dashSpeed, 0f);

    yield return new WaitForSeconds(dashDuration);

    rb.gravityScale = originalGravity;
    isDashing = false;
    animator.SetBool("Dash", false);

    yield return new WaitForSeconds(dashCooldown);
    canDash = true;
}
```

**대시 파라미터:**
- `dashSpeed = 20f` - 대시 속도
- `dashDuration = 0.2f` - 대시 지속 시간
- `dashCooldown = 1f` - 대시 쿨다운

**벽 슬라이드:**

```csharp
// PlayerController.cs - HandleWallSlide()
void HandleWallSlide()
{
    bool isTouchingWall = Physics2D.OverlapCircle(wallCheck.position, wallCheckRadius, groundLayer);

    if (isTouchingWall && !isGrounded && rb.linearVelocity.y < 0)
    {
        isWallSliding = true;
        rb.linearVelocity = new Vector2(rb.linearVelocity.x, -wallSlideSpeed);
        animator.SetBool("Wall", true);
    }
    else
    {
        isWallSliding = false;
        animator.SetBool("Wall", false);
    }
}
```

**무기 시스템 (검, 창, 메이스)**

각 무기는 고유한 공격 패턴과 데미지 계산을 가지고 있습니다.

**1. 검 (Sword) - 균형형**
```csharp
// SwordAttack.cs
public class SwordAttack : MonoBehaviour
{
    public int attackDamage = 10;
    public float attackRange = 1.5f;
    public LayerMask enemyLayer;
    public Transform attackPoint;

    public void Attack(int attackType)
    {
        // 공격 범위 내 적 감지
        Collider2D[] hitEnemies = Physics2D.OverlapCircleAll(
            attackPoint.position,
            attackRange,
            enemyLayer
        );

        // 각 적에게 데미지
        foreach (Collider2D enemy in hitEnemies)
        {
            MonsterHealth enemyHealth = enemy.GetComponent<MonsterHealth>();
            if (enemyHealth != null)
            {
                // attackType: 1 = 약공격, 2 = 강공격
                int finalDamage = attackDamage * attackType;
                enemyHealth.TakeDamage(finalDamage, attackType, "Sword");
            }
        }
    }
}
```

**2. 창 (Lance) - 리치형**
```csharp
// LanceAttack.cs
public class LanceAttack : MonoBehaviour
{
    public int attackDamage = 8;
    public float attackRange = 2.5f; // 더 긴 리치
    public float attackWidth = 0.5f;

    public void Attack(int attackType)
    {
        // BoxCast로 전방 범위 공격
        Vector2 attackDirection = transform.localScale.x > 0 ? Vector2.right : Vector2.left;

        RaycastHit2D[] hits = Physics2D.BoxCastAll(
            attackPoint.position,
            new Vector2(attackWidth, attackWidth),
            0f,
            attackDirection,
            attackRange,
            enemyLayer
        );

        foreach (RaycastHit2D hit in hits)
        {
            MonsterHealth enemyHealth = hit.collider.GetComponent<MonsterHealth>();
            if (enemyHealth != null)
            {
                enemyHealth.TakeDamage(attackDamage * attackType, attackType, "Lance");
            }
        }
    }
}
```

**3. 메이스 (Mace) - 파워형**
```csharp
// MaceAttack.cs
public class MaceAttack : MonoBehaviour
{
    public int attackDamage = 15; // 높은 데미지
    public float attackRange = 1.2f; // 짧은 리치
    public float knockbackForce = 10f;

    public void Attack(int attackType)
    {
        Collider2D[] hitEnemies = Physics2D.OverlapCircleAll(
            attackPoint.position,
            attackRange,
            enemyLayer
        );

        foreach (Collider2D enemy in hitEnemies)
        {
            MonsterHealth enemyHealth = enemy.GetComponent<MonsterHealth>();
            if (enemyHealth != null)
            {
                enemyHealth.TakeDamage(attackDamage * attackType, attackType, "Mace");

                // 넉백 효과
                Rigidbody2D enemyRb = enemy.GetComponent<Rigidbody2D>();
                if (enemyRb != null)
                {
                    Vector2 knockbackDir = (enemy.transform.position - transform.position).normalized;
                    enemyRb.AddForce(knockbackDir * knockbackForce, ForceMode2D.Impulse);
                }
            }
        }
    }
}
```

**무기별 특징 비교:**

| 무기 | 데미지 | 리치 | 공격속도 | 특수효과 |
|------|--------|------|----------|----------|
| 검 | 보통 | 보통 | 빠름 | 균형잡힌 성능 |
| 창 | 약함 | 긴 편 | 보통 | 안전한 거리 유지 |
| 메이스 | 강함 | 짧음 | 느림 | 넉백 효과 |

**공격 실행:**

```csharp
// PlayerController.cs
void Update()
{
    if (Input.GetKeyDown(KeyCode.J) && !isAttacking)
    {
        StartCoroutine(AttackRoutine());
    }
}

IEnumerator AttackRoutine()
{
    isAttacking = true;
    animator.SetTrigger("Attack");

    // 애니메이션 이벤트에서 실제 공격 실행
    // Animation Event: AttackHit()

    yield return new WaitForSeconds(attackDuration);
    isAttacking = false;
}

// Animation Event에서 호출
public void AttackHit()
{
    if (hasSword)
        swordAttack.Attack(1); // 약공격
    else if (hasLance)
        lanceAttack.Attack(1);
    else if (hasMace)
        maceAttack.Attack(1);
}
```

**체력 및 스탯 관리**

```csharp
// PlayerHealth.cs
public class PlayerHealth : MonoBehaviour
{
    public int maxHP = 100;
    public int currentHP;
    public int defense = 0;

    private bool isInvincible = false;
    public float invincibilityDuration = 1f;

    void Start()
    {
        currentHP = maxHP;
    }

    public void TakeDamage(int damage)
    {
        if (isInvincible) return;

        int finalDamage = Mathf.Max(1, damage - defense);
        currentHP -= finalDamage;

        // 대미지 텍스트 표시
        ShowDamageText(finalDamage);

        // 무적 시간 시작
        StartCoroutine(InvincibilityFrames());

        // 애니메이션
        animator.SetTrigger("Hurt");

        // 사망 체크
        if (currentHP <= 0)
        {
            Die();
        }

        // UI 업데이트
        PlayerController.Instance.UpdateAllStatsUI();
    }

    IEnumerator InvincibilityFrames()
    {
        isInvincible = true;

        // 스프라이트 깜빡임 효과
        SpriteRenderer sprite = GetComponent<SpriteRenderer>();
        for (float i = 0; i < invincibilityDuration; i += 0.1f)
        {
            sprite.enabled = !sprite.enabled;
            yield return new WaitForSeconds(0.1f);
        }
        sprite.enabled = true;

        isInvincible = false;
    }

    public void Heal(int amount)
    {
        currentHP = Mathf.Min(currentHP + amount, maxHP);
        PlayerController.Instance.UpdateAllStatsUI();
    }

    public void AddPermanentHealth(int amount)
    {
        maxHP += amount;
        currentHP += amount;
        PlayerController.Instance.UpdateAllStatsUI();
    }

    void Die()
    {
        animator.SetTrigger("Death");
        // 게임 오버 처리
        GameManager.Instance.PlayerDied();
    }
}
```

**레벨업 시스템**

```csharp
// PlayerStats.cs
public class PlayerStats : MonoBehaviour
{
    public int level = 1;
    public int currentXP = 0;
    public int xpToNextLevel = 100;

    public int bonusAttackPower = 0;
    public int bonusDefensePower = 0;
    public float bonusMoveSpeed = 0f;

    public int money = 0;
    public bool isLevelUpPending = false;

    public void AddXP(int amount)
    {
        currentXP += amount;

        while (currentXP >= xpToNextLevel)
        {
            LevelUp();
        }

        UpdateStatsUI();
    }

    void LevelUp()
    {
        level++;
        currentXP -= xpToNextLevel;
        xpToNextLevel = Mathf.RoundToInt(xpToNextLevel * 1.5f); // 1.5배씩 증가

        // 레벨업 UI 표시 (미니게임 중에는 대기)
        string currentScene = SceneManager.GetActiveScene().name;
        if (currentScene == "AncientBlacksmith" || currentScene == "LifeHeartMap")
        {
            isLevelUpPending = true;
        }
        else
        {
            ShowLevelUpPanel();
        }
    }

    void ShowLevelUpPanel()
    {
        Time.timeScale = 0f; // 시간 정지
        LevelUpUIManager levelUpUI = FindObjectOfType<LevelUpUIManager>();
        if (levelUpUI != null)
        {
            levelUpUI.ShowPanel();
        }
    }

    // 스탯 선택 (UI 버튼에서 호출)
    public void IncreaseAttack()
    {
        bonusAttackPower += 5;
        CloseLevelUpPanel();
    }

    public void IncreaseDefense()
    {
        bonusDefensePower += 3;
        CloseLevelUpPanel();
    }

    public void IncreaseHealth()
    {
        PlayerHealth health = GetComponent<PlayerHealth>();
        health.AddPermanentHealth(20);
        CloseLevelUpPanel();
    }

    public void IncreaseSpeed()
    {
        bonusMoveSpeed += 0.5f;
        CloseLevelUpPanel();
    }

    void CloseLevelUpPanel()
    {
        Time.timeScale = 1f; // 시간 재개
        LevelUpUIManager levelUpUI = FindObjectOfType<LevelUpUIManager>();
        if (levelUpUI != null)
        {
            levelUpUI.HidePanel();
        }
        PlayerController.Instance.RecalculateStats();
        PlayerController.Instance.UpdateAllStatsUI();
    }

    public void AddMoney(int amount)
    {
        money += amount;
        UpdateStatsUI();
    }

    public bool SpendMoney(int amount)
    {
        if (money >= amount)
        {
            money -= amount;
            UpdateStatsUI();
            return true;
        }
        return false;
    }
}
```

**스탯 재계산:**

```csharp
// PlayerController.cs
public void RecalculateStats()
{
    // 최종 공격력 = 기본 + 레벨 보너스 + 아이템 보너스
    int finalAttackPower = baseAttackPower + (playerStats.level * 2) + playerStats.bonusAttackPower;

    // 무기에 전달
    if (hasSword && swordAttack != null)
    {
        swordAttack.attackDamage = finalAttackPower;
    }
    else if (hasLance && lanceAttack != null)
    {
        lanceAttack.attackDamage = Mathf.RoundToInt(finalAttackPower * 0.8f); // 창은 80%
    }
    else if (hasMace && maceAttack != null)
    {
        maceAttack.attackDamage = Mathf.RoundToInt(finalAttackPower * 1.2f); // 메이스는 120%
    }

    // 방어력
    playerHealth.defense = baseDefense + playerStats.bonusDefensePower;

    // 이동속도는 Move()에서 직접 계산
    // float totalMoveSpeed = moveSpeed + playerStats.bonusMoveSpeed;
}
```

**씬 로드 시 플레이어 복원:**

```csharp
// PlayerController.cs
void OnEnable()
{
    SceneManager.sceneLoaded += OnSceneLoaded;
}

void OnDisable()
{
    SceneManager.sceneLoaded -= OnSceneLoaded;
}

void OnSceneLoaded(Scene scene, LoadSceneMode mode)
{
    // 플레이어 스폰 위치로 이동
    GameObject spawnPoint = GameObject.FindGameObjectWithTag("PlayerSpawnPoint");
    if (spawnPoint != null)
    {
        transform.position = spawnPoint.transform.position;
    }

    // 스탯 재계산
    RecalculateStats();
    UpdateAllStatsUI();

    // Auto-save
    StartCoroutine(AutoSaveAfterDelay());
}

IEnumerator AutoSaveAfterDelay()
{
    yield return new WaitForSeconds(0.5f);

    string sceneName = SceneManager.GetActiveScene().name;
    // 특정 씬은 저장 안 함
    if (sceneName != "Main" && sceneName != "LoadGame" && sceneName != "Weapon"
        && sceneName != "HowToPlay" && sceneName != "Setting")
    {
        if (GameManager.Instance != null && GameManager.Instance.currentSaveSlot > 0)
        {
            GameManager.Instance.PerformAutoSave();
        }
    }
}
```

---

#### 3.2.2 적 AI 시스템

**일반 몬스터 AI (순찰, 추적, 공격)**

기본적인 적 AI는 상태 머신 패턴을 사용하여 구현했습니다.

```csharp
// MonsterController.cs
public class MonsterController : MonoBehaviour
{
    private enum EnemyState
    {
        Idle,
        Patrol,
        Chase,
        Attack,
        Hurt,
        Dead
    }

    [Header("AI Settings")]
    private EnemyState currentState = EnemyState.Patrol;
    public float moveSpeed = 2f;
    public float chaseSpeed = 3f;
    public float detectionRange = 5f;
    public float attackRange = 1.5f;
    public float attackCooldown = 2f;

    [Header("References")]
    private Transform player;
    private Rigidbody2D rb;
    private Animator animator;

    [Header("Patrol Settings")]
    public Transform patrolPointA;
    public Transform patrolPointB;
    private Transform currentTarget;

    [Header("Ground/Wall Check")]
    public Transform groundCheck;
    public Transform wallCheck;
    public LayerMask groundLayer;
    public float checkRadius = 0.2f;

    private bool isAttacking = false;
    private bool isDead = false;

    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        animator = GetComponent<Animator>();
        player = GameObject.FindGameObjectWithTag("Player")?.transform;
        currentTarget = patrolPointB;
    }

    void Update()
    {
        if (isDead) return;

        UpdateState();
        ExecuteState();
    }

    void UpdateState()
    {
        float distanceToPlayer = Vector2.Distance(transform.position, player.position);

        switch (currentState)
        {
            case EnemyState.Patrol:
                if (distanceToPlayer <= detectionRange)
                {
                    ChangeState(EnemyState.Chase);
                }
                break;

            case EnemyState.Chase:
                if (distanceToPlayer > detectionRange)
                {
                    ChangeState(EnemyState.Patrol);
                }
                else if (distanceToPlayer <= attackRange && !isAttacking)
                {
                    ChangeState(EnemyState.Attack);
                }
                break;

            case EnemyState.Attack:
                if (distanceToPlayer > attackRange)
                {
                    ChangeState(EnemyState.Chase);
                }
                break;
        }
    }

    void ExecuteState()
    {
        switch (currentState)
        {
            case EnemyState.Patrol:
                Patrol();
                break;
            case EnemyState.Chase:
                Chase();
                break;
            case EnemyState.Attack:
                if (!isAttacking)
                    StartCoroutine(AttackRoutine());
                break;
        }
    }

    void Patrol()
    {
        // 목표 지점으로 이동
        Vector2 direction = (currentTarget.position - transform.position).normalized;
        rb.linearVelocity = new Vector2(direction.x * moveSpeed, rb.linearVelocity.y);

        // 방향 전환
        if (direction.x > 0)
            transform.localScale = new Vector3(1, 1, 1);
        else
            transform.localScale = new Vector3(-1, 1, 1);

        animator.SetFloat("Speed", Mathf.Abs(rb.linearVelocity.x));

        // 목표 도착 체크
        if (Vector2.Distance(transform.position, currentTarget.position) < 0.5f)
        {
            currentTarget = (currentTarget == patrolPointA) ? patrolPointB : patrolPointA;
        }

        // 벽이나 낭떠러지 체크
        if (CheckWall() || !CheckGround())
        {
            currentTarget = (currentTarget == patrolPointA) ? patrolPointB : patrolPointA;
        }
    }

    void Chase()
    {
        Vector2 direction = (player.position - transform.position).normalized;
        rb.linearVelocity = new Vector2(direction.x * chaseSpeed, rb.linearVelocity.y);

        // 방향 전환
        if (direction.x > 0)
            transform.localScale = new Vector3(1, 1, 1);
        else
            transform.localScale = new Vector3(-1, 1, 1);

        animator.SetFloat("Speed", Mathf.Abs(rb.linearVelocity.x));
    }

    IEnumerator AttackRoutine()
    {
        isAttacking = true;
        rb.linearVelocity = Vector2.zero; // 정지

        animator.SetBool("isAttacking", true);

        // 애니메이션 이벤트에서 실제 히트박스 활성화
        // AnimationEvent: EnableAttackHitbox()

        yield return new WaitForSeconds(attackCooldown);

        animator.SetBool("isAttacking", false);
        isAttacking = false;
    }

    // Animation Event에서 호출
    public void EnableAttackHitbox()
    {
        // AttackHitbox 활성화
        Transform hitbox = transform.Find("AttackHitbox");
        if (hitbox != null)
        {
            hitbox.gameObject.SetActive(true);
        }
    }

    public void DisableAttackHitbox()
    {
        Transform hitbox = transform.Find("AttackHitbox");
        if (hitbox != null)
        {
            hitbox.gameObject.SetActive(false);
        }
    }

    bool CheckGround()
    {
        return Physics2D.OverlapCircle(groundCheck.position, checkRadius, groundLayer);
    }

    bool CheckWall()
    {
        return Physics2D.OverlapCircle(wallCheck.position, checkRadius, groundLayer);
    }

    void ChangeState(EnemyState newState)
    {
        currentState = newState;
    }

    void OnDrawGizmosSelected()
    {
        // 감지 범위
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, detectionRange);

        // 공격 범위
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}
```

**AttackHitbox 구현:**

```csharp
// EnemyAttackHitbox.cs (AttackHitbox 오브젝트에 부착)
public class EnemyAttackHitbox : MonoBehaviour
{
    public int attackDamage = 10;
    public LayerMask playerLayer;

    void OnTriggerEnter2D(Collider2D collision)
    {
        if (((1 << collision.gameObject.layer) & playerLayer) != 0)
        {
            PlayerHealth playerHealth = collision.GetComponent<PlayerHealth>();
            if (playerHealth != null)
            {
                playerHealth.TakeDamage(attackDamage);
            }
        }
    }
}
```

**스테이지 1 중간보스 (근접 + 마법)**

Stage1MidBossAI는 기본 AI를 확장하여 마법 공격 패턴을 추가했습니다.

```csharp
// Stage1MidBossAI.cs (일부 발췌)
public class Stage1MidBossAI : MonoBehaviour
{
    [Header("Attack Settings")]
    public GameObject spellPrefab;
    public Transform spellSpawnPoint;
    public float spellCastCooldown = 5f;
    public float meleeAttackCooldown = 2f;

    private bool canCastSpell = true;
    private bool canMeleeAttack = true;
    private bool isActivated = false;

    [Header("Activation")]
    public float activationRange = 8f;

    void Update()
    {
        if (!isActivated)
        {
            // 플레이어가 범위 내에 들어오면 활성화
            if (Vector2.Distance(transform.position, player.position) <= activationRange)
            {
                isActivated = true;
                // 활성화 이벤트 (예: 대화, 음악 변경 등)
            }
            return;
        }

        // 활성화 후 AI 로직
        UpdateAI();
    }

    void UpdateAI()
    {
        float distanceToPlayer = Vector2.Distance(transform.position, player.position);

        // 거리에 따른 행동 선택
        if (distanceToPlayer > 4f && canCastSpell)
        {
            StartCoroutine(CastSpellRoutine());
        }
        else if (distanceToPlayer <= 2f && canMeleeAttack)
        {
            StartCoroutine(MeleeAttackRoutine());
        }
        else
        {
            Chase();
        }
    }

    IEnumerator CastSpellRoutine()
    {
        canCastSpell = false;
        rb.linearVelocity = Vector2.zero; // 정지

        // 캐스팅 애니메이션
        animator.SetBool("isCasting", true);
        yield return new WaitForSeconds(1f); // 캐스팅 시간

        // 스펠 소환
        SummonSpell();

        animator.SetBool("isCasting", false);

        yield return new WaitForSeconds(spellCastCooldown);
        canCastSpell = true;
    }

    void SummonSpell()
    {
        if (spellPrefab != null && spellSpawnPoint != null)
        {
            GameObject spell = Instantiate(spellPrefab, spellSpawnPoint.position, Quaternion.identity);

            // 스펠에 플레이어 타겟 전달
            SpellAttack spellScript = spell.GetComponent<SpellAttack>();
            if (spellScript != null)
            {
                spellScript.SetTarget(player);
            }
        }
    }

    IEnumerator MeleeAttackRoutine()
    {
        canMeleeAttack = false;
        rb.linearVelocity = Vector2.zero;

        animator.SetBool("isAttacking", true);

        // AnimationEvent에서 EnableAttackHitbox() 호출

        yield return new WaitForSeconds(meleeAttackCooldown);

        animator.SetBool("isAttacking", false);
        canMeleeAttack = true;
    }
}
```

**SpellAttack.cs (투사체):**

```csharp
// SpellAttack.cs
public class SpellAttack : MonoBehaviour
{
    public int damage = 15;
    public float moveSpeed = 5f;
    public float lifetime = 5f;

    private Transform target;
    private Vector2 direction;

    public void SetTarget(Transform playerTransform)
    {
        target = playerTransform;

        // 플레이어 방향 계산
        direction = (target.position - transform.position).normalized;

        // 회전
        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        transform.rotation = Quaternion.Euler(0, 0, angle);

        // 수명 타이머
        Destroy(gameObject, lifetime);
    }

    void Update()
    {
        // 직선 이동
        transform.position += (Vector3)direction * moveSpeed * Time.deltaTime;
    }

    void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Player"))
        {
            PlayerHealth playerHealth = collision.GetComponent<PlayerHealth>();
            if (playerHealth != null)
            {
                playerHealth.TakeDamage(damage);
            }
            Destroy(gameObject);
        }
        else if (collision.CompareTag("Ground"))
        {
            Destroy(gameObject);
        }
    }
}
```

**스테이지 2 중간보스 (텔레포트)**

Stage2MidBossAI는 플레이어와의 거리가 멀어지면 텔레포트하여 접근합니다.

```csharp
// Stage2MidBossAI.cs (핵심 부분 발췌)
public class Stage2MidBossAI : MonoBehaviour
{
    [Header("Teleport Settings")]
    public float teleportRange = 6f; // 이 거리 이상 멀어지면 텔레포트
    public float teleportCooldown = 3f;
    public float teleportMinX = -10f;
    public float teleportMaxX = 10f;
    public float teleportY = 0f;

    [Header("Sprite Child")]
    public bool useSpriteChild = true;
    public Transform spriteTransform;

    private bool canTeleport = true;
    private SpriteRenderer spriteRenderer;

    void Start()
    {
        if (useSpriteChild && spriteTransform != null)
        {
            spriteRenderer = spriteTransform.GetComponent<SpriteRenderer>();
        }
        else
        {
            spriteRenderer = GetComponent<SpriteRenderer>();
        }
    }

    void Update()
    {
        if (!isActivated) return;

        float distanceToPlayer = Vector2.Distance(transform.position, player.position);

        // 텔레포트 조건
        if (distanceToPlayer > teleportRange && canTeleport)
        {
            StartCoroutine(TeleportRoutine());
        }
        else if (distanceToPlayer <= attackRange && canMeleeAttack)
        {
            StartCoroutine(MeleeAttackRoutine());
        }
        else
        {
            Chase();
        }
    }

    IEnumerator TeleportRoutine()
    {
        canTeleport = false;
        rb.linearVelocity = Vector2.zero;

        // 페이드 아웃
        yield return StartCoroutine(FadeOut());

        // 랜덤 위치로 텔레포트 (플레이어 근처)
        Vector2 newPosition = GetRandomTeleportPosition();
        transform.position = newPosition;

        // 페이드 인
        yield return StartCoroutine(FadeIn());

        yield return new WaitForSeconds(teleportCooldown);
        canTeleport = true;
    }

    IEnumerator FadeOut()
    {
        float duration = 0.5f;
        float elapsed = 0f;
        Color color = spriteRenderer.color;

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float alpha = Mathf.Lerp(1f, 0f, elapsed / duration);
            spriteRenderer.color = new Color(color.r, color.g, color.b, alpha);
            yield return null;
        }

        spriteRenderer.color = new Color(color.r, color.g, color.b, 0f);
    }

    IEnumerator FadeIn()
    {
        float duration = 0.5f;
        float elapsed = 0f;
        Color color = spriteRenderer.color;

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float alpha = Mathf.Lerp(0f, 1f, elapsed / duration);
            spriteRenderer.color = new Color(color.r, color.g, color.b, alpha);
            yield return null;
        }

        spriteRenderer.color = new Color(color.r, color.g, color.b, 1f);
    }

    Vector2 GetRandomTeleportPosition()
    {
        // 플레이어 주변 랜덤 위치 (범위 내)
        float randomX = Random.Range(teleportMinX, teleportMaxX);

        // 플레이어와 너무 가깝지 않도록
        while (Mathf.Abs(randomX - player.position.x) < 2f)
        {
            randomX = Random.Range(teleportMinX, teleportMaxX);
        }

        return new Vector2(randomX, teleportY);
    }

    void OnDrawGizmosSelected()
    {
        // 텔레포트 범위 (녹색 선)
        Gizmos.color = Color.green;
        Gizmos.DrawLine(
            new Vector3(teleportMinX, teleportY, 0),
            new Vector3(teleportMaxX, teleportY, 0)
        );

        // 텔레포트 트리거 범위
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position, teleportRange);
    }
}
```

**MidBossAnimationEvents.cs (Sprite Child 패턴):**

```csharp
// MidBossAnimationEvents.cs
// Sprite 자식 오브젝트에 부착하여 애니메이션 이벤트를 부모 AI에 전달
public class MidBossAnimationEvents : MonoBehaviour
{
    private Stage1MidBossAI stage1Boss;
    private Stage2MidBossAI stage2Boss;

    void Start()
    {
        // 부모에서 AI 스크립트 찾기
        stage1Boss = GetComponentInParent<Stage1MidBossAI>();
        stage2Boss = GetComponentInParent<Stage2MidBossAI>();
    }

    // Animation Event
    public void EnableAttackHitbox()
    {
        if (stage1Boss != null)
            stage1Boss.EnableAttackHitbox();
        else if (stage2Boss != null)
            stage2Boss.EnableAttackHitbox();
    }

    public void DisableAttackHitbox()
    {
        if (stage1Boss != null)
            stage1Boss.DisableAttackHitbox();
        else if (stage2Boss != null)
            stage2Boss.DisableAttackHitbox();
    }

    public void PlayAttackSound()
    {
        if (stage1Boss != null)
            stage1Boss.PlayAttackSound();
        else if (stage2Boss != null)
            stage2Boss.PlayAttackSound();
    }

    public void PlayWalkSound()
    {
        if (stage1Boss != null)
            stage1Boss.PlayWalkSound();
        else if (stage2Boss != null)
            stage2Boss.PlayWalkSound();
    }
}
```

**체력 및 피격 시스템**

```csharp
// MonsterHealth.cs
public class MonsterHealth : MonoBehaviour
{
    [Header("Health")]
    public int maxHP = 100;
    public int currentHP;
    public int defense = 0;

    [Header("XP and Drops")]
    public int xpValue = 50;
    public ItemDrop itemDrop;

    [Header("Weapon Damage Multipliers")]
    public float swordMultiplier = 1.0f;
    public float lanceMultiplier = 0.9f;
    public float maceMultiplier = 1.2f;

    [Header("Attack Type Multipliers")]
    public float lightAttackMultiplier = 1.0f;
    public float heavyAttackMultiplier = 1.5f;

    private Animator animator;
    private bool isDead = false;

    void Start()
    {
        currentHP = maxHP;
        animator = GetComponent<Animator>();
    }

    public void TakeDamage(int baseDamage, int attackType, string weaponType)
    {
        if (isDead) return;

        // 무기 타입 배수
        float weaponMultiplier = 1.0f;
        switch (weaponType)
        {
            case "Sword":
                weaponMultiplier = swordMultiplier;
                break;
            case "Lance":
                weaponMultiplier = lanceMultiplier;
                break;
            case "Mace":
                weaponMultiplier = maceMultiplier;
                break;
        }

        // 공격 타입 배수 (1 = 약공격, 2 = 강공격)
        float attackMultiplier = (attackType == 1) ? lightAttackMultiplier : heavyAttackMultiplier;

        // 최종 데미지 계산
        int finalDamage = Mathf.RoundToInt((baseDamage - defense) * weaponMultiplier * attackMultiplier);
        finalDamage = Mathf.Max(1, finalDamage); // 최소 1 데미지

        currentHP -= finalDamage;

        // 대미지 텍스트 표시
        ShowDamageText(finalDamage);

        // 피격 애니메이션
        animator.SetTrigger("isHurt");

        // 사망 체크
        if (currentHP <= 0)
        {
            Die();
        }
    }

    void ShowDamageText(int damage)
    {
        // DamageText 프리팹 생성
        GameObject damageTextObj = Instantiate(
            damageTextPrefab,
            transform.position + Vector3.up,
            Quaternion.identity
        );

        DamageText damageText = damageTextObj.GetComponent<DamageText>();
        if (damageText != null)
        {
            damageText.SetDamage(damage);
        }
    }

    void Die()
    {
        isDead = true;
        animator.SetTrigger("isDead");

        // AI 비활성화
        MonsterController controller = GetComponent<MonsterController>();
        if (controller != null)
        {
            controller.enabled = false;
        }

        // XP 지급
        PlayerStats playerStats = PlayerController.Instance.GetComponent<PlayerStats>();
        if (playerStats != null)
        {
            playerStats.AddXP(xpValue);
        }

        // 아이템 드롭 및 파괴는 DieRoutine에서
        StartCoroutine(DieRoutine());
    }

    IEnumerator DieRoutine()
    {
        // 사망 애니메이션 재생
        yield return new WaitForSeconds(1f);

        // 이벤트 트리거 (예: MidBossController)
        MidBossController midBoss = GetComponent<MidBossController>();
        if (midBoss != null)
        {
            midBoss.OnBossDeath();
        }

        // 아이템 드롭
        if (itemDrop != null)
        {
            itemDrop.DropItems();
        }

        // 오브젝트 파괴
        Destroy(gameObject);
    }
}
```

**아이템 드롭 시스템**

```csharp
// ItemDrop.cs
public class ItemDrop : MonoBehaviour
{
    [System.Serializable]
    public class DropItem
    {
        public GameObject itemPrefab;
        [Range(0f, 1f)]
        public float dropChance = 0.5f;
        public int minQuantity = 1;
        public int maxQuantity = 3;
    }

    public DropItem[] dropItems;

    public void DropItems()
    {
        foreach (DropItem drop in dropItems)
        {
            // 확률 체크
            if (Random.value <= drop.dropChance)
            {
                int quantity = Random.Range(drop.minQuantity, drop.maxQuantity + 1);

                for (int i = 0; i < quantity; i++)
                {
                    // 랜덤 위치에 드롭
                    Vector2 dropPosition = (Vector2)transform.position + Random.insideUnitCircle * 0.5f;

                    GameObject droppedItem = Instantiate(
                        drop.itemPrefab,
                        dropPosition,
                        Quaternion.identity
                    );

                    // 물리적으로 튀어오르는 효과
                    Rigidbody2D rb = droppedItem.GetComponent<Rigidbody2D>();
                    if (rb != null)
                    {
                        Vector2 randomForce = new Vector2(
                            Random.Range(-2f, 2f),
                            Random.Range(3f, 5f)
                        );
                        rb.AddForce(randomForce, ForceMode2D.Impulse);
                    }
                }
            }
        }
    }
}
```

---

이것은 보고서의 첫 번째 부분입니다. 문서가 매우 길기 때문에 파일로 저장하고 있습니다. 계속 작성하겠습니다.
